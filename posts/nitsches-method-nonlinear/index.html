<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Nitsche's method for nonlinear problems | shapero.xyz</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://www.shapero.xyz/posts/nitsches-method-nonlinear/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Daniel Shapero">
<link rel="prev" href="../nitsches-method-stokes/" title="Nitsche's method for the Stokes equations" type="text/html">
<link rel="next" href="../yau-conjecture/" title="Yau's Conjecture" type="text/html">
<meta property="og:site_name" content="shapero.xyz">
<meta property="og:title" content="Nitsche's method for nonlinear problems">
<meta property="og:url" content="https://www.shapero.xyz/posts/nitsches-method-nonlinear/">
<meta property="og:description" content="In the past two posts, we showed how to use Nitsche's method for the Poisson equation and for the Stokes equations.
In the latter case Nitsche's method makes it possible to implement a boundary condit">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2019-10-23T09:35:34-07:00">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Header and menu bar -->
<div class="container">
      <header class="blog-header py-3"><div class="row nbb-header align-items-center">
          <div class="col-md-3 col-xs-2 col-sm-2" style="width: auto;">
            <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                
            </div>
        </div>
          <div class="col-md-6 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
            <a class="navbar-brand blog-header-logo text-dark" href="../../">

            <span id="blog-title">shapero.xyz</span>
        </a>
          </div>
            <div class="col-md-3 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
            <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav">
<li class="nav-item">
    <a href="index.ipynb" id="sourcelink" class="nav-link">Source</a>
    </li>


                    
            </ul></nav>
</div>
    </div>
</header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="../../index.html" class="nav-link">Home</a>
                </li>
<li class="nav-item">
<a href="../../archive.html" class="nav-link">Archive</a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
</nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Nitsche's method for nonlinear problems</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    Daniel Shapero
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2019-10-23T09:35:34-07:00" itemprop="datePublished" title="2019-10-23 09:35">2019-10-23 09:35</time></a>
            </p>
            
        <p class="sourceline"><a href="index.ipynb" class="sourcelink">Source</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In the past two posts, we showed how to use Nitsche's method for the Poisson equation and for the Stokes equations.
In the latter case Nitsche's method makes it possible to implement a boundary condition that cannot be enforced in the conventional way.
I got interested in all of this as a way to attack a particular problem in glacer flow.
Stokes flow is a sound physical model for predicting the velocity of glaciers, but for ice the stress tensor is a <em>power law</em> function of the strain rate tensor:</p>
$$\tau = B|\dot\varepsilon|^{\frac{1}{n} - 1}\dot\varepsilon$$<p>This begs the question of how to extend Nitsche's method for nonlinear PDE.
I don't know how to do this and I couldn't find any published papers that had, so here are my attempts.</p>
<p>Rather than go straight to the Stokes equations, I thought it might be best to try things out on the Laplace equation with a power-law nonlinearity.
For this problem we're only looking for a scalar field and not a vector field, and there's no incompressibility constraint to deal with.
The power-law Laplace problem is to minimize the functional</p>
$$J(u) = \int_\Omega\left(\frac{1}{p}k|\nabla u|^p - fu\right)dx$$<p>subject to the boundary condition $u|_{\partial\Omega} = g$.
For $p = 2$, this is a quadratic minimization problem and so the Euler-Lagrange equation is linear.
For other values of $p$ the Euler-Lagrange equations are nonlinear.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="The-Lagrange-multiplier">The Lagrange multiplier<a class="anchor-link" href="#The-Lagrange-multiplier">¶</a>
</h4>
<p>The first step that we took with Nitsche's method was to compute what the Lagrange multiplier would be if we were to use a constrained optimization-type approach to enforce the boundary conditions.
The Lagrangian is</p>
$$L(u, \lambda) = J(u) + \int_{\partial\Omega}\lambda(u - g)ds.$$<p>Using the same tricks as before, we find that</p>
$$\lambda = -k|\nabla u|^{p - 2}\frac{\partial u}{\partial n},$$<p>or in other words the Lagrange multiplier is the flux out of the boundary.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="The-Nitsche-functional">The Nitsche functional<a class="anchor-link" href="#The-Nitsche-functional">¶</a>
</h4>
<p>When we derived Nitsche's method for linear problems, we were able to start with some guess for the boundary penalty term.
The coefficients in the problem provide some physical scales that we were able to use to determine how the penalty would scale.
We could then work out the dimensionless part based on some finite element inverse inequalities.
Underlying this part of the procedure is the understanding that:</p>
<ol>
<li>a function $u$ that solves the Poisson equation will live in the Sobolev space $H^1(\Omega)$, and</li>
<li>the boundary values of a function $u$ in $H^1(\Omega)$ live in the space $H^{1/2}(\partial\Omega)$.</li>
</ol>
<p>The choice of boundary penalty is much less obvious for the p-Laplace equation.
The solution $u$ lives in the Sobolev space $W_1^p(\Omega)$, so the 2-norm of the boundary value discrepancy might be either too restrictive or not restrictive enough depending on whether $p$ is less than or greater than 2.
We'll start out with the fact that, if $u \in W_1^p(\Omega)$, then $u|_{\partial\Omega}$ is in $L^p(\partial\Omega)$.
From this we can see what happens if we try a penalty that looks like:</p>
$$J_{\text{boundary}} = \text{constant} \cdot \int_{\partial\Omega}\text{coefficients}\cdot|u - g|^p ds.$$<p>But we also need to make the units match up with those of the rest of the Lagrangian, the dimensions of which are</p>
$$[J] = \left[\int_\Omega k|\nabla u|^p dx\right] = [k] \cdot [u]^p \cdot [x]^{d - p}.$$<p>The factor of $[x]^d$ comes from the measure $dx$, while the factor of $[x]^{-p}$ comes from the gradient of $u$.
Since the surface measure $ds$ has units of $[x]^{d - 1}$, we can take the boundary penalty to be</p>
$$J_{\text{boundary}} = \text{constant}\cdot\int_{\partial\Omega}\frac{k}{ph^{p - 1}}|u - g|^p ds.$$<p>All together now, a sensible-looking Nitsche functional for the power-law Laplace equation is</p>
$$J_\gamma(u) = J(u) - \int_{\partial\Omega}k|\nabla u|^{p - 2}\frac{\partial u}{\partial n}(u - g)ds + \int_{\partial\Omega}\frac{\gamma k}{ph^{p - 1}}|u - g|^pds.$$<p>As a sanity check, observe that if $p = 2$ this is exactly equal to the Nitsche functional we derived for linear problems.
You can also view this penalty as an approximation to the <a href="https://en.wikipedia.org/wiki/Sobolev_space#Sobolev%E2%80%93Slobodeckij_spaces">Slobodeckij semi-norm</a> for functions that live in finite element spaces on meshes.</p>
<p>All we have to do now is (1) prove that it's convex for sufficiently large values of $\gamma$ and (2) determine what "sufficiently large" is.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="The-inverse-inequality">The inverse inequality<a class="anchor-link" href="#The-inverse-inequality">¶</a>
</h4>
<p>To find a value of $\gamma$ that made the Nitsche functional convex for linear problems, we used sharp bounds for the constant in the inverse inequality from a <a href="https://www.sciencedirect.com/science/article/pii/S0045782503002949">paper</a> by Warburton and Hesthaven.
As a reminder, the inverse inequality states that, if $u$ of degree $m$ on a simplex $E$ in dimension $d$ and $Tu$ is the trace of $u$ on the boundary $\partial\Omega$,</p>
$$\|Tu\|_{L^2(\partial\Omega)} \le \left(\frac{(m + 1)(m + d)}{d}\cdot\frac{|\partial E|}{|E|}\right)^{\frac{1}{2}}\|u\|_{L^2(\Omega)}.$$<p>Warburton and Hesthaven focused on estimates in the 2-norm in their paper.
In this setting, the analytical expression for orthogonal polynomials on the simplex is especially handy.</p>
<p>To prove that the Nitsche functional for the power-law Laplace equation is convex, we'll need a sharp bound on the constant in the inverse inequality for general $p$-norms.
Without the luxury of orthogonal polynomials as in the $p = 2$ case it might seem like we haven't go anywhere to go, but let's just focus on $p = \infty$ for now.
If $u$ is bounded on $\Omega$, then so is its restriction to the boundary, and</p>
$$\|Tu\|_{L^\infty(\partial\Omega)} \le \|u\|_{L^\infty(\Omega)}.$$<p>Consequently, the operation of taking traces, at least when restricted to degree-$m$ polynomials, is a bounded operator both from $L^2(\Omega) \to L^2(\partial\Omega)$ and from $L^\infty(\Omega) \to L^\infty(\partial\Omega)$.
So we can apply the <a href="https://en.wikipedia.org/wiki/Riesz%E2%80%93Thorin_theorem">Riesz-Thorin theorem</a>.
For any $p$ between 2 and $\infty$, $T$ is well-defined and bounded from $L^p(\Omega)$ to $L^p(\partial\Omega)$, and moreover</p>
$$\|T\|_p \le \|T\|_2^{2/p}\|T\|_\infty^{1 - 2/p} = \left(\frac{(m + 1)(m + d)}{d}\cdot\frac{|\partial E|}{|E|}\right)^{1/p}.$$<p>Invoking the Riesz-Thorin theorem is a little extreme, but I couldn't find a better way to arrive at the same result.
There's another hitch here in that we've only worked things out for $p$ between 2 and $\infty$ but not between 1 and 2.
There might be some elegant way to work out the sub-critical case too.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Convexity">Convexity<a class="anchor-link" href="#Convexity">¶</a>
</h4>
<p>Here's where things start to fall apart.
I think the most convenient equivalent definition of convexity for this problem is that</p>
$$\langle dJ_\gamma(u) - dJ_\gamma(v), u - v\rangle \ge 0$$<p>for all $u$ and $v$.
To verify whether this condition holds or not, we'll need to calculate the derivative of $J_\gamma$:</p>
$$\begin{align}
\langle dJ_\gamma(u), v\rangle &amp; = \int_\Omega\left(k|\nabla u|^{p - 2}\nabla u\cdot\nabla v - fv\right)dx \\
&amp;\quad  - \int_{\partial\Omega}k|\nabla u|^{p - 2}\left\{\left(I + (p - 2)\frac{\nabla u\otimes\nabla u}{|\nabla u|^2}\right)\nabla v\right\}\cdot n\cdot (u - g)\,ds \\
&amp;\qquad - \int_{\partial\Omega}k|\nabla u|^{p - 2}\frac{\partial u}{\partial n}v\, ds + \int_{\partial\Omega}\frac{\gamma k}{h^{p - 1}}|u - g|^{p - 2}(u - g)\cdot v\, ds
\end{align}$$<p>The boundary integral in the second line makes this much more complex than in the linear case.
So far I haven't succeeded.
If we wanted to instead calculate the second derivative and show that it's positive-definite, we'll have many more terms that need to be majorized and that doesn't look simple.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Experiment">Experiment<a class="anchor-link" href="#Experiment">¶</a>
</h4>
<p>I can't prove anything yet, but we can conduct an experiment to see whether my guess for a good penalty parameter will work.
First, we'll take $u$, $g$, and $f$ to be random trigonometric polynomials.
We can then calculate the second derivative of the Nitsche functional around $u$ symbolically.
To show that the second derivative is positive-definite, we can calculate its smallest eigenvalue by pulling out the assembled PETSc matrix and calling an eigensolver from the package <a href="http://slepc.upv.es/">SLEPc</a>.
If this eigenvalue is negative then I've messed up somewhere.
On the other hand, if we try this repeatedly and find that the second derivative is positive-definite for many different choices of $u$ and $g$, then we might just be onto something.</p>
<p>First, we'll create the boundary values and right-hand side as random trigonometric polynomials.
I've chosen the number of modes and coefficient decay rate to give interesting-looking but reasonable input data.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">firedrake</span>

<span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">UnitSquareMesh</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
<span class="n">degree</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Q</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="s1">'CG'</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">random_fourier_series</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">std_dev</span><span class="p">,</span> <span class="n">num_modes</span><span class="p">,</span> <span class="n">exponent</span><span class="p">):</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">SpatialCoordinate</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    
    <span class="kn">from</span> <span class="nn">firedrake</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span> <span class="k">as</span> <span class="n">π</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">std_dev</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_modes</span><span class="p">,</span> <span class="n">num_modes</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">std_dev</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_modes</span><span class="p">,</span> <span class="n">num_modes</span><span class="p">)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([(</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">π</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">l</span> <span class="o">*</span> <span class="n">y</span><span class="p">))</span> <span class="o">+</span>
                 <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">]</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">π</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">l</span> <span class="o">*</span> <span class="n">y</span><span class="p">)))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">l</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">exponent</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_modes</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_modes</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">)))])</span>
    <span class="k">return</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">random_fourier_series</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">std_dev</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">num_modes</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">random_fourier_series</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">std_dev</span><span class="o">=</span><span class="mf">.25</span><span class="p">,</span> <span class="n">num_modes</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">contours</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">tricontourf</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">contours</span><span class="p">);</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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">
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Next I'll make a random field for $u$, create the action functional for the power-law Laplace equation, and create the right boundary terms for the Nitsche functional.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">firedrake</span> <span class="kn">import</span> <span class="n">inner</span><span class="p">,</span> <span class="n">grad</span><span class="p">,</span> <span class="n">dx</span>

<span class="n">u</span> <span class="o">=</span> <span class="n">random_fourier_series</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">std_dev</span><span class="o">=</span><span class="mf">.25</span><span class="p">,</span> <span class="n">num_modes</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">J_flexion</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">p</span> <span class="o">*</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>
<span class="n">J_force</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">u</span> <span class="o">*</span> <span class="n">dx</span>
<span class="n">J_energy</span> <span class="o">=</span> <span class="n">J_flexion</span> <span class="o">-</span> <span class="n">J_force</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">firedrake</span> <span class="kn">import</span> <span class="n">ds</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">FacetNormal</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">CellSize</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
<span class="n">σ</span> <span class="o">=</span> <span class="o">-</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">**</span><span class="p">((</span><span class="n">p</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="n">J_flux</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">σ</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">*</span> <span class="n">ds</span>
<span class="n">J_boundary</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">h</span><span class="o">**</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span><span class="o">**</span><span class="n">p</span> <span class="o">*</span> <span class="n">ds</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Finally we have to calculate a good value for $\gamma$ using the Warburton-Hesthaven bound in the inverse inequality and the calculated minimum angle of the mesh.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="n">coords</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">dat</span><span class="o">.</span><span class="n">data_ro</span>
<span class="n">cells</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">cell_node_map</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>

<span class="n">θ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
<span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span>
        <span class="n">ζ</span><span class="p">,</span> <span class="n">ξ</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span> <span class="o">-</span> <span class="n">x</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">ζ</span><span class="p">,</span> <span class="n">ξ</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">ζ</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span><span class="p">(</span><span class="n">ξ</span><span class="p">)))</span>
        <span class="n">θ</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">θ</span><span class="p">)</span>
        
<span class="n">α</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
<span class="n">γ</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">α</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">degree</span> <span class="o">*</span> <span class="p">(</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">θ</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">θ</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can now put everything together to make the Nitsche functional.
Then we can compute the second derivatives of these functional around $u$ symbolically and assemble them into PETSc matrices.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">firedrake</span> <span class="kn">import</span> <span class="n">assemble</span><span class="p">,</span> <span class="n">derivative</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">J_energy</span> <span class="o">+</span> <span class="n">J_flux</span> <span class="o">+</span> <span class="n">γ</span> <span class="o">*</span> <span class="n">J_boundary</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

<span class="n">ϕ</span><span class="p">,</span> <span class="n">ψ</span> <span class="o">=</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">TestFunction</span><span class="p">(</span><span class="n">Q</span><span class="p">),</span> <span class="n">firedrake</span><span class="o">.</span><span class="n">TrialFunction</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">ϕ</span> <span class="o">*</span> <span class="n">ψ</span> <span class="o">*</span> <span class="n">dx</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">M</span><span class="o">.</span><span class="n">handle</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">M</span><span class="o">.</span><span class="n">handle</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Finally we'll solve an eigenproblem using SLEPc.
The options we pass to SLEPc state that we're solving a generalized Hermitian eigenvalue problem, we're looking for the smallest real eigenvalue, and that we'll shift and invert the matrix to accelerate the solver. 
I'm using GMRES as a Krylov subspace solve rather than conjugate gradients because we're not sure that the matrix is postive definite.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">petsc4py</span> <span class="kn">import</span> <span class="n">PETSc</span>
<span class="kn">from</span> <span class="nn">slepc4py</span> <span class="kn">import</span> <span class="n">SLEPc</span>

<span class="n">opts</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Options</span><span class="p">()</span>
<span class="n">opts</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="s1">'eps_gen_hermitian'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="n">opts</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="s1">'eps_target_real'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="n">opts</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="s1">'eps_smallest_real'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="n">opts</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="s1">'st_type'</span><span class="p">,</span> <span class="s1">'sinvert'</span><span class="p">)</span>
<span class="n">opts</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="s1">'st_ksp_type'</span><span class="p">,</span> <span class="s1">'gmres'</span><span class="p">)</span>
<span class="n">opts</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="s1">'st_pc-type'</span><span class="p">,</span> <span class="s1">'jacobi'</span><span class="p">)</span>
<span class="n">opts</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="s1">'eps_tol'</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">)</span>

<span class="n">num_values</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">eigensolver</span> <span class="o">=</span> <span class="n">SLEPc</span><span class="o">.</span><span class="n">EPS</span><span class="p">()</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">comm</span><span class="o">=</span><span class="n">firedrake</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">)</span>
<span class="n">eigensolver</span><span class="o">.</span><span class="n">setDimensions</span><span class="p">(</span><span class="n">num_values</span><span class="p">)</span>
<span class="n">eigensolver</span><span class="o">.</span><span class="n">setOperators</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
<span class="n">eigensolver</span><span class="o">.</span><span class="n">setFromOptions</span><span class="p">()</span>
<span class="n">eigensolver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">num_converged</span> <span class="o">=</span> <span class="n">eigensolver</span><span class="o">.</span><span class="n">getConverged</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">num_converged</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>2
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">Vr</span><span class="p">,</span> <span class="n">Vi</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">getVecs</span><span class="p">()</span>
<span class="n">λ</span> <span class="o">=</span> <span class="n">eigensolver</span><span class="o">.</span><span class="n">getEigenpair</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Vr</span><span class="p">,</span> <span class="n">Vi</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>And the moment of truth:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">λ</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>(50.43828292612783+0j)
</pre>
</div>
</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>which is well and truly positive!
In every test I've run so far it seems as if the second derivative of the Nitsche functional is positive-definite.
Of course these tests are run using a few random fields, which is far from exhaustive.
I still need a proof that my proposed value of the penalty parameter is good enough, but for now it's encouraging to know that it might work.</p>

</div>
</div>
</div>
    </div>
    <aside class="postpromonav"><nav><ul class="pager hidden-print">
<li class="previous">
                <a href="../nitsches-method-stokes/" rel="prev" title="Nitsche's method for the Stokes equations">Previous post</a>
            </li>
            <li class="next">
                <a href="../yau-conjecture/" rel="next" title="Yau's Conjecture">Next post</a>
            </li>
        </ul></nav></aside><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-3lJUsx1TJHt7BA4udB5KPnDrlkO8T6J6v/op7ui0BbCjvZ9WqV4Xm6DTP6kQ/iBH" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
    },
    displayAlign: 'center', // Change this to 'left' if you want left-aligned equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}}
    }
});
</script></article><!--End of body content--><footer id="footer">
            Contents © 2022         <a href="mailto:shapero.daniel@gmail.com">Daniel Shapero</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
            
        </footer>
</div>
</div>


        <script src="../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
